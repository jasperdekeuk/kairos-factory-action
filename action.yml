name: 'Kairos Factory Action'
description: 'Build Kairos immutable images and artifacts within your release pipeline'

inputs:
  # Working directory
  workdir:
    description: 'Working directory where the Kairos source lives (must contain images/)'
    required: false
    default: '.'
  
  # Core build parameters
  base_image:
    description: 'Base image to use for building Kairos (e.g., ubuntu:24.04, opensuse/leap:15.6)'
    required: false
    default: 'ubuntu:24.04'
  
  model:
    description: 'Target model for the build (e.g., generic, rpi3, nvidia-jetson-agx-orin)'
    required: false
    default: 'generic'
  
  arch:
    description: 'Target architecture (amd64, arm64)'
    required: false
    default: 'amd64'
  
  kubernetes_distro:
    description: 'Kubernetes distribution to include (k3s, k0s)'
    required: false
  
  kubernetes_version:
    description: 'Kubernetes version to include (auto for latest, or specific version)'
    required: false
    default: 'auto'
  
  version:
    description: 'Version for the build (semver or "auto" for git describe)'
    required: true
  
  trusted_boot:
    description: 'Enable trusted boot support'
    required: false
    default: 'false'
  
  # Artifact generation
  artifacts:
    description: 'Comma-separated list of artifacts to generate (iso,raw,vhd,gce,tar)'
    required: false
    default: 'iso'
  
  # Individual artifact types (for workflow compatibility)
  iso:
    description: 'Generate ISO artifact'
    required: false
    default: 'false'
  
  raw:
    description: 'Generate RAW artifact'
    required: false
    default: 'false'
  
  vhd:
    description: 'Generate VHD artifact'
    required: false
    default: 'false'
  
  gce:
    description: 'Generate GCE artifact'
    required: false
    default: 'false'
  
  tar:
    description: 'Generate TAR artifact'
    required: false
    default: 'false'
  
  output_format:
    description: 'Output format override (auto, docker, oci)'
    required: false
    default: 'auto'
  
  # Security and signing
  security_checks:
    description: 'Comma-separated list of security checks (cosign,grype,trivy)'
    required: false
    default: ''
  
  sign_artifacts:
    description: 'Sign generated artifacts with cosign'
    required: false
    default: 'false'
  
  # Individual security checks (for workflow compatibility)
  cosign:
    description: 'Sign artifacts with cosign'
    required: false
    default: 'false'
  
  grype:
    description: 'Run Grype security scan'
    required: false
    default: 'false'
  
  # Publishing
  push_repository:
    description: 'Repository to push the image to (e.g., ghcr.io/user/repo)'
    required: false
  
  push_repository_username:
    description: 'Username for push repository authentication'
    required: false
  
  push_repository_password:
    description: 'Password/token for push repository authentication'
    required: false
  
  # Output and reporting
  summary_artifacts:
    description: 'Add artifact links to GitHub Summary'
    required: false
    default: 'false'
  
  auroraboot_version:
    description: 'Auroraboot version to use for artifact generation'
    required: false
    default: 'latest'

outputs:
  image_tag:
    description: 'The generated image tag'
    value: ${{ steps.setup.outputs.image_tag }}
  
  artifacts:
    description: 'JSON array of generated artifacts'
    value: ${{ steps.generate-artifacts.outputs.artifacts }}
  
  summary:
    description: 'Build summary for GitHub Summary'
    value: ${{ steps.generate-summary.outputs.summary }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        # Change to working directory
        echo "üìÅ Changing to working directory: ${{ inputs.workdir }}"
        cd "${{ inputs.workdir }}"
        
        # Validate that images/ directory exists
        if [ ! -d "images" ]; then
          echo "‚ùå Error: images/ directory not found in ${{ inputs.workdir }}"
          echo "   Current directory: $(pwd)"
          echo "   Directory contents: $(ls -la)"
          exit 1
        fi
        
        echo "‚úÖ Found images/ directory in ${{ inputs.workdir }}"
        
        # Validate required inputs
        if [[ -z "${{ inputs.version }}" ]]; then
          echo "‚ùå Error: version is required"
          exit 1
        fi
        
        # Validate kubernetes_distro values
        if [[ -n "${{ inputs.kubernetes_distro }}" ]]; then
          case "${{ inputs.kubernetes_distro }}" in
            k3s|k0s)
              ;;
            *)
              echo "‚ùå Error: kubernetes_distro must be 'k3s' or 'k0s'"
              exit 1
              ;;
          esac
        fi
        
        # Validate arch values
        case "${{ inputs.arch }}" in
          amd64|arm64)
            ;;
          *)
            echo "‚ùå Error: arch must be 'amd64' or 'arm64'"
            exit 1
            ;;
        esac
        
        # Validate artifacts
        if [[ -n "${{ inputs.artifacts }}" ]]; then
          IFS=',' read -ra ARTIFACTS <<< "${{ inputs.artifacts }}"
          for artifact in "${ARTIFACTS[@]}"; do
            case "$artifact" in
              iso|raw|vhd|gce|tar)
                ;;
              *)
                echo "‚ùå Error: Invalid artifact type '$artifact'. Must be one of: iso,raw,vhd,gce,tar"
                exit 1
                ;;
            esac
          done
        fi
        
        echo "‚úÖ Input validation passed"

    - name: Process boolean inputs
      id: process-inputs
      shell: bash
      run: |
        # Convert boolean artifact inputs to comma-separated list
        ARTIFACTS_LIST=""
        if [[ "${{ inputs.iso }}" == "true" ]]; then
          ARTIFACTS_LIST="${ARTIFACTS_LIST}iso"
        fi
        if [[ "${{ inputs.raw }}" == "true" ]]; then
          if [[ -n "$ARTIFACTS_LIST" ]]; then
            ARTIFACTS_LIST="${ARTIFACTS_LIST},raw"
          else
            ARTIFACTS_LIST="raw"
          fi
        fi
        if [[ "${{ inputs.vhd }}" == "true" ]]; then
          if [[ -n "$ARTIFACTS_LIST" ]]; then
            ARTIFACTS_LIST="${ARTIFACTS_LIST},vhd"
          else
            ARTIFACTS_LIST="vhd"
          fi
        fi
        if [[ "${{ inputs.gce }}" == "true" ]]; then
          if [[ -n "$ARTIFACTS_LIST" ]]; then
            ARTIFACTS_LIST="${ARTIFACTS_LIST},gce"
          else
            ARTIFACTS_LIST="gce"
          fi
        fi
        if [[ "${{ inputs.tar }}" == "true" ]]; then
          if [[ -n "$ARTIFACTS_LIST" ]]; then
            ARTIFACTS_LIST="${ARTIFACTS_LIST},tar"
          else
            ARTIFACTS_LIST="tar"
          fi
        fi
        
        # Use original artifacts input if no boolean inputs are set
        if [[ -z "$ARTIFACTS_LIST" ]]; then
          ARTIFACTS_LIST="${{ inputs.artifacts }}"
        fi
        
        # Convert boolean security inputs to comma-separated list
        SECURITY_LIST=""
        if [[ "${{ inputs.cosign }}" == "true" ]]; then
          SECURITY_LIST="cosign"
        fi
        if [[ "${{ inputs.grype }}" == "true" ]]; then
          if [[ -n "$SECURITY_LIST" ]]; then
            SECURITY_LIST="${SECURITY_LIST},grype"
          else
            SECURITY_LIST="grype"
          fi
        fi
        
        # Use original security_checks input if no boolean inputs are set
        if [[ -z "$SECURITY_LIST" ]]; then
          SECURITY_LIST="${{ inputs.security_checks }}"
        fi
        
        # Set sign_artifacts based on cosign boolean input
        SIGN_ARTIFACTS="${{ inputs.sign_artifacts }}"
        if [[ "${{ inputs.cosign }}" == "true" ]]; then
          SIGN_ARTIFACTS="true"
        fi
        
        echo "artifacts=$ARTIFACTS_LIST" >> $GITHUB_OUTPUT
        echo "security_checks=$SECURITY_LIST" >> $GITHUB_OUTPUT
        echo "sign_artifacts=$SIGN_ARTIFACTS" >> $GITHUB_OUTPUT
        
        echo "üîß Processed inputs:"
        echo "   Artifacts: $ARTIFACTS_LIST"
        echo "   Security checks: $SECURITY_LIST"
        echo "   Sign artifacts: $SIGN_ARTIFACTS"

    - name: Setup environment
      id: setup
      shell: bash
      run: |
        # Determine variant based on kubernetes_distro
        if [[ -n "${{ inputs.kubernetes_distro }}" ]]; then
          VARIANT="standard"
        else
          VARIANT="core"
        fi
        
        # Handle version resolution
        if [[ "${{ inputs.version }}" == "auto" ]]; then
          VERSION=$(git describe --tags --dirty --always)
        else
          VERSION="${{ inputs.version }}"
        fi
        
        # Handle kubernetes version resolution
        if [[ "${{ inputs.kubernetes_version }}" == "auto" ]]; then
          KUBERNETES_VERSION=""
        else
          KUBERNETES_VERSION="${{ inputs.kubernetes_version }}"
        fi
        
        # Split base image for tag generation
        BASE_IMAGE=$(echo "${{ inputs.base_image }}" | cut -d ':' -f 1)
        TAG=$(echo "${{ inputs.base_image }}" | cut -d ':' -f 2 || echo 'latest')
        
        # Handle special cases for base images with slashes
        if [[ "$BASE_IMAGE" == *"/"* ]]; then
          DISTRO=$(echo "$BASE_IMAGE" | cut -d '/' -f 1)
          SUB_DISTRO=$(echo "$BASE_IMAGE" | cut -d '/' -f 2)
          FLAVOR="$DISTRO"
          FLAVOR_RELEASE="$SUB_DISTRO-$TAG"
        else
          FLAVOR="$BASE_IMAGE"
          FLAVOR_RELEASE="$TAG"
        fi
        
        # Special case for nvidia
        if [[ "${{ inputs.model }}" == "nvidia-jetson-agx-orin" ]]; then
          FLAVOR="ubuntu"
          FLAVOR_RELEASE="22.04"
        fi
        
        # Generate image tag
        if [[ -n "$KUBERNETES_VERSION" ]]; then
          # Replace + with - in kubernetes version for tag compatibility
          SANITIZED_KUBERNETES_VERSION=$(echo "$KUBERNETES_VERSION" | sed 's/+/-/g')
          IMAGE_TAG="${{ inputs.push_repository || 'kairos' }}/$FLAVOR:$FLAVOR_RELEASE-$VARIANT-${{ inputs.arch }}-${{ inputs.model }}-$VERSION-${{ inputs.kubernetes_distro }}-$SANITIZED_KUBERNETES_VERSION${{ inputs.trusted_boot == 'true' && '-uki' || '' }}"
        else
          IMAGE_TAG="${{ inputs.push_repository || 'kairos' }}/$FLAVOR:$FLAVOR_RELEASE-$VARIANT-${{ inputs.arch }}-${{ inputs.model }}-$VERSION${{ inputs.trusted_boot == 'true' && '-uki' || '' }}"
        fi
        
        # Export variables
        echo "variant=$VARIANT" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "kubernetes_version=$KUBERNETES_VERSION" >> $GITHUB_OUTPUT
        echo "flavor=$FLAVOR" >> $GITHUB_OUTPUT
        echo "flavor_release=$FLAVOR_RELEASE" >> $GITHUB_OUTPUT
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        echo "üîß Environment setup complete"
        echo "   Variant: $VARIANT"
        echo "   Version: $VERSION"
        echo "   Image Tag: $IMAGE_TAG"

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@master
      with:
        platforms: linux/${{ inputs.arch }}

    - name: Login to registry
      if: inputs.push_repository != ''
      uses: docker/login-action@v3
      with:
        registry: ${{ startsWith(inputs.push_repository, 'ghcr.io') && 'ghcr.io' || startsWith(inputs.push_repository, 'quay.io') && 'quay.io' || 'docker.io' }}
        username: ${{ inputs.push_repository_username }}
        password: ${{ inputs.push_repository_password }}

    - name: Build Kairos image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: images/Dockerfile
        platforms: linux/${{ inputs.arch }}
        push: ${{ inputs.push_repository != '' }}
        load: ${{ inputs.push_repository == '' }}
        tags: ${{ steps.setup.outputs.image_tag }}
        build-args: |
          BASE_IMAGE=${{ inputs.base_image }}
          MODEL=${{ inputs.model }}
          KUBERNETES_VERSION=${{ steps.setup.outputs.kubernetes_version }}
          KUBERNETES_DISTRO=${{ inputs.kubernetes_distro }}
          TRUSTED_BOOT=${{ inputs.trusted_boot }}
          VERSION=${{ steps.setup.outputs.version }}

    - name: Run security scans
      if: contains(steps.process-inputs.outputs.security_checks, 'grype')
      uses: anchore/scan-action@v6.3.0
      with:
        image: ${{ steps.setup.outputs.image_tag }}
        output-format: json
        severity-cutoff: critical
        add-cpes-if-none: true
        only-fixed: true
        fail-build: false

    - name: Run Trivy scan
      if: contains(steps.process-inputs.outputs.security_checks, 'trivy')
      uses: aquasecurity/trivy-action@76071ef0d7ec797419534a183b498b4d6366cf37 # 0.31.0
      with:
        image-ref: ${{ steps.setup.outputs.image_tag }}
        format: sarif
        output: trivy.sarif
        severity: CRITICAL
        limit-severities-for-sarif: true

    - name: Generate artifacts
      id: generate-artifacts
      if: steps.process-inputs.outputs.artifacts != ''
      shell: bash
      run: |
        mkdir -p artifacts
        
        IFS=',' read -ra ARTIFACT_TYPES <<< "${{ steps.process-inputs.outputs.artifacts }}"
        GENERATED_ARTIFACTS=()
        
        for artifact_type in "${ARTIFACT_TYPES[@]}"; do
          case "$artifact_type" in
            iso)
              if [[ "${{ inputs.model }}" == "generic" ]]; then
                echo "üì¶ Building ISO artifact..."
                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                  -v $PWD/artifacts:/output \
                  quay.io/kairos/auroraboot:${{ inputs.auroraboot_version }} \
                  --debug build-iso --output /output/ \
                  docker:${{ steps.setup.outputs.image_tag }}
                
                ISO_FILE=$(ls artifacts/*.iso | head -1)
                if [[ -n "$ISO_FILE" ]]; then
                  GENERATED_ARTIFACTS+=("$ISO_FILE")
                  echo "‚úÖ ISO generated: $ISO_FILE"
                fi
              else
                echo "‚ö†Ô∏è  ISO generation only supported for generic model"
              fi
              ;;
            
            raw)
              if [[ "${{ inputs.model }}" != "rpi3" && "${{ inputs.model }}" != "generic" && "${{ inputs.model }}" != "nvidia-jetson-agx-orin" ]]; then
                echo "üì¶ Building RAW artifact..."
                docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock \
                  -v $PWD/artifacts:/output \
                  quay.io/kairos/auroraboot:${{ inputs.auroraboot_version }} \
                  --debug \
                  --set "disable_http_server=true" \
                  --set "disable_netboot=true" \
                  --set "container_image=${{ steps.setup.outputs.image_tag }}" \
                  --set "state_dir=/output" \
                  --set "disk.raw=true"
                
                RAW_FILE=$(ls artifacts/*.raw | head -1)
                if [[ -n "$RAW_FILE" ]]; then
                  GENERATED_ARTIFACTS+=("$RAW_FILE")
                  echo "‚úÖ RAW generated: $RAW_FILE"
                fi
              else
                echo "‚ö†Ô∏è  RAW generation not supported for ${{ inputs.model }} model"
              fi
              ;;
            
            vhd|gce|tar)
              echo "üì¶ Building $artifact_type artifact..."
              # Implementation for other artifact types would go here
              echo "‚ö†Ô∏è  $artifact_type generation not yet implemented"
              ;;
          esac
        done
        
        # Export artifacts list
        if [[ ${#GENERATED_ARTIFACTS[@]} -gt 0 ]]; then
          echo "artifacts=$(printf '%s\n' "${GENERATED_ARTIFACTS[@]}" | jq -R . | jq -s .)" >> $GITHUB_OUTPUT
        fi

    - name: Sign artifacts
      if: steps.process-inputs.outputs.sign_artifacts == 'true'
      shell: bash
      run: |
        # Install cosign
        curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
        chmod +x cosign-linux-amd64
        sudo mv cosign-linux-amd64 /usr/local/bin/cosign
        
        # Sign image
        cosign sign ${{ steps.setup.outputs.image_tag }}
        
        # Sign generated artifacts
        if [[ -n "${{ steps.generate-artifacts.outputs.artifacts }}" ]]; then
          IFS=$'\n' read -d '' -r -a ARTIFACTS <<< "${{ steps.generate-artifacts.outputs.artifacts }}"
          for artifact in "${ARTIFACTS[@]}"; do
            if [[ -f "$artifact" ]]; then
              cosign sign-blob --yes --output-certificate="${artifact}.pem" --output-signature="${artifact}.sig" "$artifact"
              echo "‚úÖ Signed: $artifact"
            fi
          done
        fi

    - name: Generate summary
      id: generate-summary
      if: inputs.summary_artifacts == 'true'
      shell: bash
      run: |
        SUMMARY="## üè≠ Kairos Factory Build Summary\n\n"
        SUMMARY+="**Image:** \`${{ steps.setup.outputs.image_tag }}\`\n\n"
        SUMMARY+="**Configuration:**\n"
        SUMMARY+="- Base Image: \`${{ inputs.base_image }}\`\n"
        SUMMARY+="- Model: \`${{ inputs.model }}\`\n"
        SUMMARY+="- Architecture: \`${{ inputs.arch }}\`\n"
        SUMMARY+="- Variant: \`${{ steps.setup.outputs.variant }}\`\n"
        SUMMARY+="- Version: \`${{ steps.setup.outputs.version }}\`\n"
        
        if [[ -n "${{ inputs.kubernetes_distro }}" ]]; then
          SUMMARY+="- Kubernetes: \`${{ inputs.kubernetes_distro }}\` \`${{ steps.setup.outputs.kubernetes_version }}\`\n"
        fi
        
        if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
          SUMMARY+="- Trusted Boot: ‚úÖ Enabled\n"
        fi
        
        SUMMARY+="\n**Generated Artifacts:**\n"
        
        if [[ -n "${{ steps.generate-artifacts.outputs.artifacts }}" ]]; then
          IFS=$'\n' read -d '' -r -a ARTIFACTS <<< "${{ steps.generate-artifacts.outputs.artifacts }}"
          for artifact in "${ARTIFACTS[@]}"; do
            if [[ -f "$artifact" ]]; then
              SUMMARY+="- \`$(basename "$artifact")\`\n"
            fi
          done
        else
          SUMMARY+="- No artifacts generated\n"
        fi
        
        if [[ "${{ steps.process-inputs.outputs.sign_artifacts }}" == "true" ]]; then
          SUMMARY+="\n**Security:**\n"
          SUMMARY+="- ‚úÖ Image signed with cosign\n"
          if [[ -n "${{ steps.generate-artifacts.outputs.artifacts }}" ]]; then
            SUMMARY+="- ‚úÖ Artifacts signed with cosign\n"
          fi
        fi
        
        if [[ -n "${{ steps.process-inputs.outputs.security_checks }}" ]]; then
          SUMMARY+="\n**Security Scans:**\n"
          IFS=',' read -ra CHECKS <<< "${{ steps.process-inputs.outputs.security_checks }}"
          for check in "${CHECKS[@]}"; do
            SUMMARY+="- ‚úÖ $check scan completed\n"
          done
        fi
        
        echo "summary<<EOF" >> $GITHUB_OUTPUT
        echo "$SUMMARY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Upload artifacts
      if: steps.process-inputs.outputs.artifacts != ''
      uses: actions/upload-artifact@v4
      with:
        name: kairos-artifacts-${{ steps.setup.outputs.flavor }}-${{ steps.setup.outputs.flavor_release }}-${{ steps.setup.outputs.variant }}-${{ inputs.arch }}-${{ inputs.model }}
        path: ${{ inputs.workdir }}/artifacts/
        if-no-files-found: warn 